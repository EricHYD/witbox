#!/usr/bin/python

import os,sys,re
import shutil
import platform
from optparse import OptionParser
from xml.etree import ElementTree
from datetime import date

# fixme
g_home = ''
g_user = ''
g_conf = {}

# fixme!
def setup_email(distrib, version, group):
	# host = 'smtp.' + domain
	now = date.today()
	term = "cs%d%d" % (now.year % 100, (now.month + 1) / 2)

	if g_conf.has_key('email'):
		email = g_conf['email']
	else:
		email = user_to_mail(g_conf['name'])

	if g_conf.has_key('epass'):
		epass = g_conf['epass']
	else:
		epass = 'MW%s' % term

	domain = email.split('@')[1]

	for pkg in group:
		rc = '%s/.%src' % (g_home, pkg)

		if os.path.exists(rc):
			if not g_conf.has_key('email') and not g_conf.has_key('epass'):
				continue
			print 'updating %src ...' % pkg
		else:
			print 'generating %src ...' % pkg

		if pkg == 'msmtp':
			if os.path.exists(rc):
				if g_conf.has_key('email'):
					os.system('sed -i "s/user\s.*/user %s/" %s' % (email, rc))
					os.system('sed -i "s/from\s.*/from %s/" %s' % (email, rc))

				if g_conf.has_key('epass'):
					os.system('sed -i "s/password\s.*/password %s/" %s' % (epass, rc))

				os.system('sed -i "s/host\s.*/host smtp.%s/" %s' % (domain, rc))

				continue

			fd = open(rc, 'w+')
			fd.write('defaults\n\n')
			fd.write('account %s\n' % domain)
			fd.write('host smtp.%s\n' % domain)
			fd.write('user %s\n' % email)
			fd.write('from %s\n' % email)
			fd.write('password %s\n' % epass)
			fd.write('auth login\n\n')
			fd.write('account default: %s' % domain)
			fd.close()
		elif pkg == 'fetchmail':
			if os.path.exists(rc):
				if g_conf.has_key('email'):
					os.system('sed -i "s/user\s.*/user %s/" %s' % (email, rc))
					os.system('sed -i "s/poll\s.*/poll pop.%s with protocol pop3/"' % domain)

				if g_conf.has_key('epass'):
					os.system('sed -i "s/password\s.*/password %s/" %s' % (epass, rc))

				os.system('sed -i "s/host\s.*/host smtp.%s/" %s' % (domain, rc))

				continue

			fd = open(rc, 'w+')
			fd.write('set daemon 600\n')
			fd.write('poll pop.%s with protocol pop3\n' % domain)
			fd.write('uidl\n')
			fd.write('user "%s"\n' % email)
			fd.write('password "%s"\n' % epass)
			fd.write('keep\n')
			fd.write('mda "/usr/bin/procmail -d %T"\n')
			fd.close()
		elif pkg == 'procmail':
			if os.path.exists(rc):
				continue

			fd = open(rc, 'w+')
			fd.write('MAILDIR=$HOME/Mail\n')
			fd.write('DEFAULT=$MAILDIR/Inbox/\n')
			fd.close()
		elif pkg == "mutt":
			if os.path.exists(rc):
				if g_conf.has_key('email'):
					os.system('sed -i "s/my_hdr\s+Reply-To:.*/my_hdr Reply-To: %s/" %s' % (email, rc))

				continue

			fd = open(rc, 'w+')
			# smtp setting
			fd.write('# smtp setting\n')
			fd.write('set sendmail = /usr/bin/msmtp\n')
			fd.write('# set use_from = yes\n')
			fd.write('# set envelope_from = yes\n')
			fd.write('\n')
			# general setting
			fd.write('# general setting\n')
			fd.write('my_hdr From: %s\n' % mail)
			#fd.write('my_hdr Reply-To: %s\n' % mail)
			#fd.write('my_hdr Reply-To: \"%s\" <%s>\n' % (user, mail))
			fd.write('\n')

			fd_rc = open('app/mail/muttrc.common')
			for line in fd_rc:
				fd.write(line)
			fd_rc.close()

			fd.close()

			# signature
			fd = open(g_home + '/Mail/signature', 'w+')
			fd.write('Regards,\n%s\n' % user)
			fd.close()
		else:
			print '%s not configured' % pkg
			continue

		os.chmod(rc, 0600)

def user_to_mail(user):
	return user.lower().replace(' ', '.') + '@maxwit.com'

def setup_git(distrib, version, group):
	fname = g_conf['name']
	if g_conf.has_key('email'):
		email = g_conf['email']
	else:
		email = user_to_mail(fname)

	# fixme
	os.system('app/git/setup.sh "%s" "%s"' % (fname, email))

def setup_vim(distrib, version, group):
	print 'configuring vimrc ...'
	dst = open(g_home + '/.vimrc', 'w+')
	src = open('app/vim/vimrc')
	for line in src:
		dst.write(line)
	src.close()
	dst.close()

def setup_serial(distrib, version, group):
	dst = open(g_home + '/.kermrc', 'w+')
	src = open('app/kermit/kermrc')
	for line in src:
		dst.write(line)
	src.close()
	dst.close()

def traverse(node, path):
	if not os.path.exists(path):
		print "creating \"%s\"" % path
		os.mkdir(path)
	#else:
	#	print "skipping \"%s\"" % path
	lst = node.getchildren()
	for n in lst:
		traverse(n, path + '/' + n.attrib['name'])

# population the target directory
def populate_tree(fn):
	tree = ElementTree.parse(fn)
	root = tree.getroot()

	top = '/' + root.attrib['name']

	mounted = False
	fd_chk = open('/proc/mounts')
	for line in fd_chk:
		mount = line.split(' ')
		if mount[1] == top:
			mounted = True
			break
	fd_chk.close()

	if mounted == False:
		print '"%s" NOT mounted!' % top
		exit()

	if not os.access(top, 7):
		print 'Fail to access "' + top + '", permission denied!'
		exit()
		#os.system('sudo chown $USER ' + top) # fixme!

	traverse(root, top)

def get_user_info():
	fd_rept = open('/etc/passwd', 'r')

	for line in fd_rept:
		account = line.split(':')
		user_name = account[0]
		if user_name == g_user:
			full_name = account[4].split(',')[0]
			break

	fd_rept.close()

	return full_name

def do_install(distrib, version, curr_arch, install_list):
	upgrade  = ''
	install  = ''
	tree = ElementTree.parse(r'app/apps.xml')
	root = tree.getroot()
	dist_list = root.getchildren()

	do_setup = {'mutt': setup_email, 'git': setup_git, 'vim': setup_vim,
	'serial': setup_serial}

	for dist_node in dist_list:
		if dist_node.attrib['name'] == distrib:
			upgrade = dist_node.attrib['upgrade']
			install = dist_node.attrib['install']

			if upgrade != '':
				os.system('sudo ' + upgrade)
				print

			release_list = dist_node.getchildren()
			for release in release_list:
				ver = release.attrib['version']
				if ver == 'all' or ver == version:
					for pkg in install_list:
						for app_node in release.getchildren():
							if curr_arch != app_node.get('arch', curr_arch):
								continue

							members = re.split('\s+', app_node.text)
							if install_list[0] == 'ALL' or pkg in members:
								group = app_node.get('group')
								#attr_post = app_node.get('post')

								print 'Installing %s:\n  %s' % (group.upper(), app_node.text)
								os.system('sudo ' + install + ' ' +  app_node.text)

								#if attr_post != None:
								#	os.system('cd app/%s && ./%s' % (group, attr_post))
								if do_setup.has_key(group):
									do_setup[group](distrib, version, members)

								print

					if ver == version:
						return

def config():
	g_conf['name'] = get_user_info()
	g_conf['apps'] = 'ALL'

def setup():
	distrib = platform.dist()[0].lower()
	version = platform.dist()[1].lower()
	arch = platform.processor()
	apps = re.split('\s+', g_conf['apps'])

	do_install(distrib, version, arch, apps);

def main():
	parser = OptionParser()
	parser.add_option('-m', '--email', dest='email',
					  help="E-mail Account")
	parser.add_option('-p', '--epass', dest='epass',
					  help="E-mail Password")
	parser.add_option('-v', '--version', dest='version',
					  default=False, action='store_true',
					  help="show PowerTool version and exit")

	(opts, args) = parser.parse_args()

	if opts.version:
		print "  MaxWit PowerTool %s (by MaxWit Software, http://www.maxwit.com)" % "v3.4-beta"
		exit()

	if opts.email != None:
		g_conf['email'] = opts.email

	if opts.epass != None:
		g_conf['epass'] = opts.epass

	config()

	setup()

	populate_tree('tree/tree.xml')

	exit()

if __name__ == "__main__":
	g_user = os.getenv('USER')
	g_home = os.getenv('HOME')
	if g_user == 'root':
		print 'cannot run as root!'
		exit()

	main()
